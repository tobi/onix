#!/usr/bin/env ruby
# frozen_string_literal: true

# Lint: scan for leaked secrets, credentials, and private keys.
#
# Two scopes:
#   1. Repo files (bin/, overlays/, tests/, docs/, *.md, *.nix) — strict, zero tolerance
#   2. Gem sources (nix/gem/*/*/source/) — flag real secrets, allow known test fixtures
#
# Patterns detected:
#   - Private keys (RSA, DSA, EC, OPENSSH, PGP)
#   - AWS access key IDs (AKIA...)
#   - AWS secret keys
#   - GitHub/GitLab tokens
#   - Generic API keys, passwords, secrets in config
#   - .env files with credentials
#   - Slack/Discord webhooks
#   - Database connection strings with passwords
#   - JWT secrets
#   - Base64-encoded key material

require "pathname"
require "set"

ROOT = Pathname.new(File.expand_path("../..", __dir__))

# ── Patterns ──────────────────────────────────────────────────────────────

PATTERNS = {
  "Private key (PEM)" => /-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----/,
  "AWS access key" => /(?<![A-Z0-9])AKIA[0-9A-Z]{16}(?![A-Z0-9])/,
  "AWS secret key" => /(?:aws_secret_access_key|secret_key)\s*[:=]\s*["']?[A-Za-z0-9\/+=]{40}["']?/i,
  "GitHub token" => /(?:ghp|gho|ghu|ghs|ghr)_[A-Za-z0-9_]{36,}/,
  "GitLab token" => /glpat-[A-Za-z0-9\-_]{20,}/,
  "Slack webhook" => %r{https://hooks\.slack\.com/services/T[A-Z0-9]+/B[A-Z0-9]+/[A-Za-z0-9]+},
  "Slack token" => /xox[bpors]-[0-9]+-[0-9]+-[A-Za-z0-9]+/,
  "Discord webhook" => %r{https://discord(?:app)?\.com/api/webhooks/[0-9]+/[A-Za-z0-9_-]+},
  "Heroku API key" => /(?:heroku_api_key|HEROKU_API_KEY)\s*[:=]\s*["']?[0-9a-f]{8}-[0-9a-f]{4}/i,
  "Generic secret assignment" => /(?:SECRET_KEY|API_SECRET|PRIVATE_KEY|AUTH_TOKEN|ACCESS_TOKEN)[\s]*[:=][\s]*["'][^"']{8,}["']/,
  "Password in URL" => %r{://[^/\s]+:[^@/\s]{8,}@[^/\s]+},
  "Hardcoded password" => /(?:password|passwd|pwd)\s*[:=]\s*["'][^"']{8,}["']/i,
}.freeze

# ── Allowlists ────────────────────────────────────────────────────────────

# Paths in gem sources that are known test fixtures / documentation / library code.
# These contain example/test keys that are not real secrets.
GEM_PATH_ALLOWLIST = [
  # Test fixtures & spec data — keys generated for testing, not real
  %r{/spec/fixtures/},
  %r{/test/fixtures/},
  %r{/spec/support/},
  %r{/test/support/},
  %r{/spec/mock_response/},
  %r{/tests?/.*\.(key|pem|crt|cert)$},
  %r{/tests?/.*test_ssl},
  %r{/sample/ssl/},
  %r{/test/files/},

  # node_modules inside git gems (vendored JS test deps)
  %r{/node_modules/},

  # Library code that handles keys (parsers, factories, documentation)
  %r{/lib/net/ssh/},                       # net-ssh key parsing code
  %r{/ext/openssl/},                       # openssl C extension source
  %r{/stdlib/openssl/},                    # rbs type definitions
  %r{/lib/aws-sdk-.*/client\.rb$},         # AWS SDK example strings in docs
  %r{/lib/aws_cf_signer\.rb$},             # example in docs
  %r{/lib/chef-config/},                   # chef config parsing code
  %r{/lib/kamal/configuration/docs/},      # kamal documentation YAML
  %r{/lib/twilio-ruby/},                   # twilio API definitions
  %r{/lib/fog/},                           # fog cloud API code
  %r{/lib/fastlane/},                      # fastlane action docs
  %r{/lib/marcel/tables\.rb$/},            # MIME type tables
  %r{/lib/gpgme/},                         # gpgme library code
  %r{/lib/restforce/},                     # restforce library code

  # README / documentation containing example keys
  %r{/README\.md$},
  %r{/CHANGELOG\.md$},

  # C source code that references key format strings
  %r{/ext/ssl\.cpp$},                      # eventmachine SSL
].freeze

# Content patterns that indicate example/documentation, not real secrets
GEM_CONTENT_ALLOWLIST = [
  /AKIAIOSFODNN7EXAMPLE/,                  # AWS's official example key
  /wJalrXUtnFEMI\/K7MDENG\/bPxRfiCYEXAMPLEKEY/, # AWS's official example secret
  /EXAMPLE/i,
  /example\.com/,
  /your[_-]?api[_-]?key/i,
  /your[_-]?secret/i,
  /replace[_-]?with/i,
  /placeholder/i,
  /TODO/,
  /changeme/i,
  /insert[_-]?here/i,
  /xxxx/i,
].freeze

# ── Scanner ───────────────────────────────────────────────────────────────

Finding = Struct.new(:file, :line_num, :pattern_name, :line, :scope)

def scan_file(path, scope)
  findings = []
  rel = path.relative_path_from(ROOT).to_s

  begin
    content = File.read(path, encoding: "utf-8", mode: "rb")
  rescue ArgumentError, Encoding::InvalidByteSequenceError
    return findings # skip binary files
  end

  # Skip binary-looking files
  return findings if content[0..512]&.include?("\x00")

  content.each_line.with_index(1) do |line, num|
    PATTERNS.each do |name, re|
      next unless line.match?(re)

      if scope == :gem
        # Check path allowlist
        next if GEM_PATH_ALLOWLIST.any? { |pat| pat.match?(rel) }

        # Check content allowlist
        next if GEM_CONTENT_ALLOWLIST.any? { |pat| pat.match?(line) }
      end

      findings << Finding.new(rel, num, name, line.strip[0..120], scope)
    end
  end

  findings
end

def scan_directory(dir, scope, extensions: nil)
  findings = []
  return findings unless dir.exist?

  dir.find do |path|
    next unless path.file?
    next if path.to_s.include?("/.git/")
    next if path.to_s.end_with?("tests/lint/secrets") # don't scan self

    if extensions
      next unless extensions.any? { |ext| path.to_s.end_with?(ext) }
    end

    # Skip large files (>1MB) — likely data/vendored
    next if path.size > 1_048_576

    findings.concat(scan_file(path, scope))
  end

  findings
end

# ── Main ──────────────────────────────────────────────────────────────────

findings = []

# Scope 1: Repo files — strict
repo_dirs = %w[bin overlays tests docs imports].map { |d| ROOT.join(d) }
repo_dirs.each { |d| findings.concat(scan_directory(d, :repo)) }

# Top-level files
ROOT.children.select { |f| f.file? && %w[.md .nix .rb .sh .yml .yaml .toml .json .lock].include?(f.extname) }.each do |f|
  findings.concat(scan_file(f, :repo))
end

# Scope 2: Gem sources
gem_source = ROOT.join("nix/gem")
if gem_source.exist?
  gem_source.glob("*/*/source").each do |source_dir|
    next unless source_dir.directory?
    findings.concat(scan_directory(source_dir, :gem))
  end
end

# ── Report ────────────────────────────────────────────────────────────────

if findings.empty?
  gem_count = gem_source.exist? ? gem_source.glob("*/*/source").count { |d| d.directory? } : 0
  puts "secrets: OK (scanned repo + #{gem_count} gem sources, 0 findings)"
  exit 0
end

# Group by scope
repo_findings = findings.select { |f| f.scope == :repo }
gem_findings = findings.select { |f| f.scope == :gem }

unless repo_findings.empty?
  puts "=== REPO FILES (strict — must fix) ==="
  repo_findings.each do |f|
    puts "  #{f.file}:#{f.line_num}: [#{f.pattern_name}] #{f.line}"
  end
  puts
end

unless gem_findings.empty?
  puts "=== GEM SOURCES (review — may need allowlist) ==="
  # Group by gem
  by_gem = gem_findings.group_by { |f| f.file.split("/")[0..3].join("/") }
  by_gem.each do |gem_path, gfindings|
    puts "  #{gem_path}/ (#{gfindings.size} findings)"
    gfindings.first(3).each do |f|
      puts "    #{f.file}:#{f.line_num}: [#{f.pattern_name}]"
    end
    puts "    ... and #{gfindings.size - 3} more" if gfindings.size > 3
  end
  puts
end

total = findings.size
puts "secrets: #{total} findings (#{repo_findings.size} repo, #{gem_findings.size} gem sources)"
exit repo_findings.empty? ? 0 : 1
