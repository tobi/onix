#!/usr/bin/env ruby
# frozen_string_literal: true

# generate-gemset — produce a project .nix gemset from its Gemfile.lock
#
# Produces: nix/app/<project>.nix
# Returns a list of gem entries. Use with resolve.nix:
#   resolve { inherit pkgs ruby; gemset = import ./nix/app/<project>.nix; }
#
# Git gems use builtins.fetchGit at nix eval time — no pre-fetch needed.
# The gemset carries full git info: url, rev, branch.
#
# Usage:
#   generate-gemset fizzy ../fizzy/Gemfile.lock

require "bundler"
require "digest"
require "fileutils"
require "uri"

OVERLAYS_DIR = File.join(__dir__, "..", "overlays")

project   = ARGV[0] or abort "Usage: generate-gemset <project> <Gemfile.lock>"
lockfile  = ARGV[1] or abort "Usage: generate-gemset <project> <Gemfile.lock>"
output_dir = File.join(__dir__, "..", "nix", "gem")

gemfile = lockfile.sub(/Gemfile\.lock$/, "Gemfile")
ENV["BUNDLE_GEMFILE"] = File.expand_path(gemfile) if File.exist?(gemfile)

lf = Bundler::LockfileParser.new(File.read(lockfile))

# Which gems have overlays?
overlays = {}
if Dir.exist?(OVERLAYS_DIR)
  Dir.glob(File.join(OVERLAYS_DIR, "*.nix")).each do |f|
    overlays[File.basename(f, ".nix")] = true
  end
end

# Classify specs
rubygem_specs = []
git_specs = []

lf.specs.each do |spec|
  src = spec.source
  case src
  when Bundler::Source::Git
    base = File.basename(src.uri, ".git")
    git_specs << {
      spec: spec,
      uri: src.uri,
      rev: src.revision,
      branch: src.branch,
      base: base,
      shortrev: src.revision[0, 12],
    }
  when Bundler::Source::Path
    next
  else
    existing = rubygem_specs.find { |s| s.name == spec.name }
    if existing
      rubygem_specs.delete(existing) if spec.platform.to_s == "ruby"
      next unless spec.platform.to_s == "ruby"
    end
    rubygem_specs << spec
  end
end

# Group git specs by repo+rev
git_repos = {}
git_specs.each do |gs|
  key = "#{gs[:base]}-#{gs[:shortrev]}"
  unless git_repos[key]
    git_repos[key] = {
      uri: gs[:uri],
      rev: gs[:rev],
      branch: gs[:branch],
      base: gs[:base],
      shortrev: gs[:shortrev],
      gems: [],
    }
  end
  git_repos[key][:gems] << gs[:spec] unless git_repos[key][:gems].any? { |e| e.name == gs[:spec].name }
end

$stderr.puts "#{project}: #{rubygem_specs.size} rubygems, #{git_specs.size} git (#{git_repos.size} repos)"

# -- Generate gemset .nix --------------------------------------------------

nix = +""
nix << "#\n"
nix << "# ╔══════════════════════════════════════════════════════════════════╗\n"
nix << "# ║  GENERATED — do not edit.  Run bin/generate-gemset to refresh  ║\n"
nix << "# ╚══════════════════════════════════════════════════════════════════╝\n"
nix << "#\n"
nix << "# #{project.upcase} — #{rubygem_specs.size + git_specs.size} gems\n"
nix << "# Generated from #{File.basename(lockfile)}\n"
nix << "#\n"
nix << "[\n"

rubygem_specs.sort_by(&:name).each do |spec|
  nix << "  { name = #{spec.name.inspect}; version = #{spec.version.to_s.inspect}; }\n"
end

git_repos.each do |_repo_key, repo|
  nix << "  # git: #{repo[:base]} @ #{repo[:shortrev]}\n"
  git_attrs = []
  git_attrs << "rev = #{repo[:shortrev].inspect}"
  git_attrs << "url = #{repo[:uri].inspect}"
  git_attrs << "branch = #{repo[:branch].inspect}" if repo[:branch]
  nix << "  {\n"
  nix << "    name = #{repo[:base].inspect};\n"
  nix << "    git = {\n"
  git_attrs.each { |a| nix << "      #{a};\n" }
  nix << "    };\n"
  nix << "  }\n"
end

nix << "]\n"

FileUtils.mkdir_p(output_dir)
app_dir = File.join(output_dir, "..", "app")
FileUtils.mkdir_p(app_dir)
File.write(File.join(app_dir, "#{project}.nix"), nix)
$stderr.puts "  -> nix/app/#{project}.nix"

# -- Generate git repo derivations -----------------------------------------

SH = "        "  # 8 spaces — shell commands (nixfmt heredoc style)
HD = "    "      # 4 spaces — heredoc body / terminator

git_repos.each do |repo_key, repo|
  git_dir = File.join(output_dir, repo[:base], "git-#{repo[:shortrev]}")
  FileUtils.mkdir_p(git_dir)

  # Check for cached source (optional — for checking gemspecs)
  source_dir = nil
  repo[:gems].each do |spec|
    candidate = File.join(__dir__, "..", "cache", "sources", "#{spec.name}-#{spec.version}")
    if Dir.exist?(candidate)
      source_dir = File.expand_path(candidate)
      break
    end
  end

  # Determine which gems need a generated gemspec
  missing_gemspecs = if source_dir
    repo[:gems].select do |spec|
      !File.exist?(File.join(source_dir, "#{spec.name}.gemspec")) &&
        !File.exist?(File.join(source_dir, spec.name, "#{spec.name}.gemspec"))
    end
  else
    # No cached source — generate gemspecs for all gems to be safe.
    # builtins.fetchGit will provide the real source at build time;
    # if real gemspecs exist in the repo the conditional below skips them.
    repo[:gems]
  end

  has_heredoc = !missing_gemspecs.empty?
  si = has_heredoc ? SH : "    "

  gnix = +""
  gnix << "#\n"
  gnix << "# ╔══════════════════════════════════════════════════════════════════╗\n"
  gnix << "# ║  GENERATED — do not edit.  Run bin/generate-gemset to refresh  ║\n"
  gnix << "# ╚══════════════════════════════════════════════════════════════════╝\n"
  gnix << "#\n"
  gnix << "# Git: #{repo[:base]} @ #{repo[:shortrev]}\n"
  gnix << "# URI: #{repo[:uri]}\n"
  gnix << "# Gems: #{repo[:gems].map(&:name).join(", ")}\n"
  gnix << "#\n"
  gnix << "{\n"
  gnix << "  lib,\n"
  gnix << "  stdenv,\n"
  gnix << "  ruby,\n"
  gnix << "}:\n"
  gnix << "let\n"
  gnix << "  rubyVersion = \"${ruby.version.majMin}.0\";\n"
  gnix << "  prefix = \"ruby/${rubyVersion}\";\n"
  gnix << "in\n"
  gnix << "stdenv.mkDerivation {\n"
  gnix << "  pname = #{repo[:base].inspect};\n"
  gnix << "  version = #{repo[:shortrev].inspect};\n"

  # Use builtins.fetchGit — nix fetches the repo at eval time, pinned to rev.
  # allRefs = true lets nix find the rev without knowing which branch it's on.
  gnix << "  src = builtins.fetchGit {\n"
  gnix << "    url = #{repo[:uri].inspect};\n"
  gnix << "    rev = #{repo[:rev].inspect};\n"
  gnix << "    allRefs = true;\n"
  gnix << "  };\n\n"

  gnix << "  dontBuild = true;\n"
  gnix << "  dontConfigure = true;\n\n"
  gnix << "  passthru = { inherit prefix; };\n\n"

  gnix << "  installPhase = ''\n"
  gnix << "#{si}local dest=$out/${prefix}/bundler/gems/#{repo_key}\n"
  gnix << "#{si}mkdir -p $dest\n"
  gnix << "#{si}cp -r . $dest/\n"
  gnix << "#{si}rm -rf $dest/.git\n"

  missing_gemspecs.each do |spec|
    # Only write gemspec if the repo doesn't already have one
    gnix << "#{si}if [ ! -f $dest/#{spec.name}.gemspec ] && [ ! -f $dest/#{spec.name}/#{spec.name}.gemspec ]; then\n"
    gnix << "#{si}  cat > $dest/#{spec.name}.gemspec <<'EOF'\n"
    gnix << "#{HD}Gem::Specification.new do |s|\n"
    gnix << "#{HD}  s.name = #{spec.name.inspect}\n"
    gnix << "#{HD}  s.version = #{spec.version.to_s.inspect}\n"
    gnix << "#{HD}  s.summary = #{spec.name.inspect}\n"
    gnix << "#{HD}  s.require_paths = [\"lib\"]\n"
    gnix << "#{HD}  s.files = []\n"
    gnix << "#{HD}end\n"
    gnix << "#{HD}EOF\n"
    gnix << "#{si}fi\n"
  end

  gnix << "  '';\n"
  gnix << "}\n"

  File.write(File.join(git_dir, "default.nix"), gnix)
  $stderr.puts "  -> nix/gem/#{repo[:base]}/git-#{repo[:shortrev]}/"

  # Remove stale source symlink (no longer needed — using fetchGit)
  source_link = File.join(git_dir, "source")
  File.delete(source_link) if File.symlink?(source_link)

  # Patch the git rev into the selector's gitRevs attrset
  selector_path = File.join(output_dir, repo[:base], "default.nix")
  if File.exist?(selector_path)
    selector = File.read(selector_path)
    rev_line = "    #{repo[:shortrev].inspect} = import ./git-#{repo[:shortrev]} { inherit lib stdenv ruby; };\n"
    unless selector.include?(repo[:shortrev].inspect)
      selector.sub!("  gitRevs = {\n", "  gitRevs = {\n#{rev_line}")
      File.write(selector_path, selector)
    end
  else
    # No rubygems version exists — create a git-only selector
    sel = +""
    sel << "#\n"
    sel << "# ╔══════════════════════════════════════════════════════════════╗\n"
    sel << "# ║  GENERATED — do not edit.  Run bin/generate to regenerate  ║\n"
    sel << "# ╚══════════════════════════════════════════════════════════════╝\n"
    sel << "#\n"
    sel << "# #{repo[:base]} (git only)\n"
    sel << "#\n"
    sel << "# Available git revs:\n"
    sel << "#   #{repo[:shortrev]}\n"
    sel << "#\n"
    sel << "# Usage:\n"
    sel << "#   #{repo[:base]} { git.rev = #{repo[:shortrev].inspect}; }\n"
    sel << "#\n"
    sel << "{\n"
    sel << "  lib,\n"
    sel << "  stdenv,\n"
    sel << "  ruby,\n"
    sel << "  pkgs ? null,\n"
    sel << "  version ? null,\n"
    sel << "  git ? { },\n"
    sel << "}:\n"
    sel << "let\n"
    sel << "  versions = { };\n\n"
    sel << "  gitRevs = {\n"
    sel << "    #{repo[:shortrev].inspect} = import ./git-#{repo[:shortrev]} { inherit lib stdenv ruby; };\n"
    sel << "  };\n"
    sel << "in\n"
    sel << "if git ? rev then\n"
    sel << "  gitRevs.\${git.rev}\n"
    sel << "    or (throw \"#{repo[:base]}: unknown git rev '\${git.rev}'. Available: \${builtins.concatStringsSep \", \" (builtins.attrNames gitRevs)}\")\n"
    sel << "else if version != null then\n"
    sel << "  throw \"#{repo[:base]}: no rubygems versions, only git revs: \${builtins.concatStringsSep \", \" (builtins.attrNames gitRevs)}\"\n"
    sel << "else\n"
    sel << "  throw \"#{repo[:base]}: specify git.rev — available: \${builtins.concatStringsSep \", \" (builtins.attrNames gitRevs)}\"\n"

    FileUtils.mkdir_p(File.dirname(selector_path))
    File.write(selector_path, sel)

    # Also add git-only gem to the top-level catalogue
    top_path = File.join(output_dir, "..", "modules", "gem.nix")
    if File.exist?(top_path)
      top = File.read(top_path, encoding: "UTF-8")
      entry = "  #{repo[:base].inspect} = args: gem #{repo[:base].inspect} args;\n"
      unless top.include?(entry)
        top.sub!(/^}\n\z/, "#{entry}}\n")
        File.write(top_path, top)
      end
    end
  end
end
