#!/usr/bin/env ruby
# frozen_string_literal: false

# scint-to-nix generate
#
# Reads a Gemfile.lock + scint cache -> writes nix derivation tree.
#
# Per-gem output:
#   default.nix  - always overwritten by generate (DO NOT EDIT)
#   compile.nix  - manual overrides, never overwritten. Only created for
#                  gems that need native compilation.
#
# Usage:
#   generate --lockfile path/to/Gemfile.lock --output out/gems/

require "json"
require "yaml"
require "fileutils"

SCINT_LIB = File.expand_path("../../scint/lib", __dir__)
$LOAD_PATH.unshift(SCINT_LIB)
require "scint"

# Gems provided by Ruby itself — filter these from dependency lists.
RUBY_PROVIDED = %w[bundler rubygems].freeze

# Known native build inputs for gems that need system libraries.
# Loaded from native-deps.yml (project default) with optional per-project override.
def load_native_deps(*paths)
  merged = {}
  paths.each do |path|
    next unless path && File.exist?(path)
    data = YAML.safe_load(File.read(path)) || {}
    data.each { |gem, deps| merged[gem] = Array(deps) }
  end
  merged.freeze
end

GENERATED_HEADER = "# AUTO-GENERATED by scint-to-nix/bin/generate -- DO NOT EDIT\n# Edit compile.nix for build overrides.\n".freeze

def header
  GENERATED_HEADER.dup
end

# -- CLI -------------------------------------------------------------------

lockfile_path    = nil
output_dir       = nil
cache_root       = nil
extra_native_deps = nil

i = 0
while i < ARGV.length
  case ARGV[i]
  when "--lockfile",    "-l" then lockfile_path    = ARGV[i += 1]
  when "--output",      "-o" then output_dir       = ARGV[i += 1]
  when "--cache",       "-c" then cache_root       = ARGV[i += 1]
  when "--native-deps", "-n" then extra_native_deps = ARGV[i += 1]
  when "--help",        "-h"
    $stderr.puts "Usage: generate -l Gemfile.lock -o out/gems/ [-c cache_root] [-n native-deps.yml]"
    exit 0
  else abort "Unknown option: #{ARGV[i]}"
  end
  i += 1
end

abort "Missing --lockfile" unless lockfile_path
abort "Missing --output"   unless output_dir

# -- Load native deps config -----------------------------------------------

default_native_deps = File.join(File.expand_path("..", __dir__), "native-deps.yml")
NATIVE_DEPS = load_native_deps(default_native_deps, extra_native_deps)

# -- Resolve gems ----------------------------------------------------------

project_dir = File.dirname(File.expand_path(lockfile_path))
Scint.cache_root = cache_root if cache_root
bundle = Scint::Bundle.new(project_dir)

# Use the library to parse lockfile, filter platforms, extract metadata
exported_gems, path_skipped = Scint::Cache::Export.from_lockfile(bundle)
unless path_skipped.empty?
  $stderr.puts "Skipped #{path_skipped.size} PATH-sourced gem(s): #{path_skipped.join(", ")}"
end

# -- Export sources & build gem metadata -----------------------------------

output_dir = File.expand_path(output_dir)
FileUtils.mkdir_p(output_dir)

name_to_attr = {}
exported_gems.each { |g| name_to_attr[g.name] = g.name }

gems = exported_gems.map do |eg|
  dir = File.join(output_dir, eg.full_name)
  deps = eg.dependencies.reject { |d| RUBY_PROVIDED.include?(d) || path_skipped.include?(d) }

  # Export source (no-op if already exists)
  eg.export(File.join(dir, "source"))

  {
    name: eg.name, version: eg.version, platform: "ruby",
    full_name: eg.full_name, nix_attr: eg.name,
    deps: deps,
    needs_compilation: eg.has_extensions,
    native_deps: eg.has_extensions ? (NATIVE_DEPS[eg.name] || []) : [],
    source_subdir: eg.source_subdir,
    require_paths: eg.require_paths,
    executables: eg.executables,
    bindir: eg.bindir,
    is_platform_gem: eg.platform_gem?,
    nix_platform_expr: eg.nix_platform_expr,
    git_source: eg.git_source? ? { checkout_dir: eg.git_checkout_dir } : nil,
    exported: eg,
  }
end

copied = gems.count { |g| g[:exported].exported? }

gems.each do |g|
  dir = File.join(output_dir, g[:full_name])
  name    = g[:name]
  version = g[:version]

  # -- compile.nix (never overwritten) --
  compile_nix_path = File.join(dir, "compile.nix")
  if g[:needs_compilation] && !File.exist?(compile_nix_path)
    cnix = "# compile.nix for #{name} #{version}\n"
    cnix << "#\n"
    cnix << "# Override build behaviour here. This file is never overwritten by generate.\n"
    cnix << "# default.nix imports this and merges the attrs below.\n"
    cnix << "#\n"
    cnix << "# Known native deps: #{g[:native_deps].inspect}\n"
    cnix << "{\n"
    cnix << "  nativeBuildInputs = [];\n"
    cnix << "  preBuild = \"\";\n"
    cnix << "  postBuild = \"\";\n"
    cnix << "  preInstall = \"\";\n"
    cnix << "  postInstall = \"\";\n"
    cnix << "}\n"
    File.write(compile_nix_path, cnix)
  end

  # -- default.nix (always overwritten) --

  nix = header
  nix << "# #{name} #{version}\n"

  if g[:needs_compilation]
    args = %w[lib stdenv ruby]
    args.concat(g[:native_deps])
    args << "gemDeps ? {}"
    args << "gemPlatform ? null" if g[:is_platform_gem]
    nix << "{ #{args.join(", ")} }:\n\n"
    nix << "let\n"
    nix << "  compile = import ./compile.nix;\n"
    if g[:is_platform_gem]
      nix << "  gemFullName = if gemPlatform != null then \"#{name}-#{version}-${gemPlatform}\" else \"#{name}-#{version}\";\n"
    end
    nix << "in\n\n"
    nix << "stdenv.mkDerivation {\n"
    nix << "  pname = \"#{name}\";\n"
    nix << "  version = \"#{version}\";\n"
    nix << "  src = ./source;\n\n"

    native = (["ruby"] + g[:native_deps]).join(" ")
    nix << "  nativeBuildInputs = [ #{native} ] ++ compile.nativeBuildInputs;\n\n"

    nix << "  buildPhase = ''\n"
    nix << "    ${compile.preBuild}\n"
    nix << "    for extconf in $(find ext -name extconf.rb 2>/dev/null); do\n"
    nix << "      dir=$(dirname \"$extconf\")\n"
    nix << "      echo \"Building extension in $dir\"\n"
    nix << "      (cd \"$dir\" && ruby extconf.rb && make -j$NIX_BUILD_CORES)\n"
    nix << "    done\n"
    nix << "    for makefile in $(find ext -name Makefile 2>/dev/null); do\n"
    nix << "      dir=$(dirname \"$makefile\")\n"
    nix << "      target_name=$(sed -n 's/^TARGET = //p' \"$makefile\")\n"
    nix << "      target_prefix=$(sed -n 's/^target_prefix = //p' \"$makefile\")\n"
    nix << "      if [ -n \"$target_name\" ] && [ -f \"$dir/$target_name.so\" ]; then\n"
    nix << "        mkdir -p \"lib$target_prefix\"\n"
    nix << "        cp \"$dir/$target_name.so\" \"lib$target_prefix/$target_name.so\"\n"
    nix << "        echo \"Installed $dir/$target_name.so -> lib$target_prefix/$target_name.so\"\n"
    nix << "      fi\n"
    nix << "    done\n"
    nix << "    ${compile.postBuild}\n"
    nix << "  '';\n\n"
  else
    args = %w[lib stdenv ruby]
    args << "gemDeps ? {}"
    args << "gemPlatform ? null" if g[:is_platform_gem]
    nix << "{ #{args.join(", ")} }:\n\n"
    if g[:is_platform_gem]
      nix << "let\n"
      nix << "  gemFullName = if gemPlatform != null then \"#{name}-#{version}-${gemPlatform}\" else \"#{name}-#{version}\";\n"
      nix << "in\n\n"
    end
    nix << "stdenv.mkDerivation {\n"
    nix << "  pname = \"#{name}\";\n"
    nix << "  version = \"#{version}\";\n"
    nix << "  src = ./source;\n\n"
    nix << "  dontBuild = true;\n"
  end

  nix << "  dontConfigure = true;\n\n"

  unless g[:deps].empty?
    nix << "  propagatedBuildInputs = [\n"
    g[:deps].each { |d| nix << "    (gemDeps.\"#{d}\" or null)\n" }
    nix << "  ];\n\n"
  end

  nix << "  installPhase = ''\n"
  if g[:needs_compilation]
    nix << "    ${compile.preInstall}\n"
  end

  if g[:is_platform_gem]
    nix << "    mkdir -p $out/gems/${gemFullName}\n"
    nix << "    cp -r . $out/gems/${gemFullName}/\n"
    nix << "    mkdir -p $out/specifications\n"
    nix << "    cat > $out/specifications/${gemFullName}.gemspec <<GEMSPEC\n"
  else
    nix << "    mkdir -p $out/gems/#{name}-#{version}\n"
    nix << "    cp -r . $out/gems/#{name}-#{version}/\n"
    nix << "    mkdir -p $out/specifications\n"
    nix << "    cat > $out/specifications/#{name}-#{version}.gemspec <<'GEMSPEC'\n"
  end
  nix << "    Gem::Specification.new do |s|\n"
  nix << "      s.name = \"#{name}\"\n"
  nix << "      s.version = \"#{version}\"\n"
  if g[:is_platform_gem]
    # gemPlatform is a Nix string interpolated into the heredoc.
    # The Ruby `if` guard prevents setting platform when gemPlatform is null/"".
    nix << "      s.platform = \"${toString gemPlatform}\" unless \"${toString gemPlatform}\".empty?\n"
  end
  nix << "      s.summary = \"#{name}\"\n"
  nix << "      s.require_paths = [#{g[:require_paths].map { |p| "\"#{p}\"" }.join(", ")}]\n"
  unless g[:executables].empty?
    nix << "      s.bindir = \"#{g[:bindir]}\"\n"
    nix << "      s.executables = [#{g[:executables].map { |e| "\"#{e}\"" }.join(", ")}]\n"
  end
  nix << "      s.files = []\n"
  g[:deps].each { |d| nix << "      s.add_dependency \"#{d}\"\n" }
  nix << "    end\n"
  nix << "    GEMSPEC\n"
  if g[:needs_compilation]
    nix << "    ${compile.postInstall}\n"
  end
  nix << "  '';\n"
  nix << "}\n"

  File.write(File.join(dir, "default.nix"), nix)
end

# -- top-level default.nix (always regenerated) ----------------------------

platform_gems = gems.select { |g| g[:is_platform_gem] }

nix = header
nix << "{ pkgs ? import <nixpkgs> {}, ruby ? pkgs.ruby }:\n\n"
nix << "let\n"

unless platform_gems.empty?
  nix << "  hp = pkgs.stdenv.hostPlatform;\n\n"
  platform_gems.each do |g|
    nix << "  gemPlatform_#{g[:name].gsub("-", "_")} =\n"
    nix << "    #{g[:nix_platform_expr]};\n\n"
  end
end

nix << "  gems = {\n"

gems.each do |g|
  nix << "\n    \"#{g[:nix_attr]}\" = pkgs.callPackage ./#{g[:full_name]} {\n"
  nix << "      inherit ruby;\n"
  valid_deps = g[:deps].select { |d| name_to_attr[d] }
  unless valid_deps.empty?
    nix << "      gemDeps = { inherit (gems)"
    valid_deps.each { |d| nix << " \"#{d}\"" }
    nix << "; };\n"
  end
  nix << "      gemPlatform = gemPlatform_#{g[:name].gsub("-", "_")};\n" if g[:is_platform_gem]
  nix << "    };\n"
end

nix << "\n  };\nin gems\n"
File.write(File.join(output_dir, "default.nix"), nix)

# -- Git checkout derivations (for monorepo git sources) -------------------

rubygems_gems = gems.reject { |g| g[:git_source] }
git_gems = gems.select { |g| g[:git_source] }

# Group git gems by checkout dir
git_checkouts = {}
git_gems.each do |g|
  dir = g[:git_source][:checkout_dir]
  git_checkouts[dir] ||= []
  git_checkouts[dir] << g
end

# For each git checkout, export the merged source and write a derivation
git_checkouts.each do |checkout_dir, group|
  checkout_out_dir = File.join(output_dir, "_git_#{checkout_dir}")
  source_dir = File.join(checkout_out_dir, "source")

  # Export the full merged tree — the library already merged monorepo dirs
  unless Dir.exist?(source_dir)
    group.first[:exported].export(source_dir, full: true)
    $stderr.puts "  Merged git checkout: #{checkout_dir} from #{group.size} gem(s)"
  end

  # Write default.nix — simple copy, no build
  nix = header
  nix << "# Git checkout: #{checkout_dir}\n"
  nix << "{ lib, stdenv }:\n\n"
  nix << "stdenv.mkDerivation {\n"
  nix << "  pname = \"git-checkout-#{checkout_dir}\";\n"
  nix << "  version = \"0.0.1\";\n"
  nix << "  src = ./source;\n"
  nix << "  dontBuild = true;\n"
  nix << "  dontConfigure = true;\n"
  nix << "  installPhase = ''\n"
  nix << "    mkdir -p $out\n"
  nix << "    cp -r . $out/\n"
  nix << "  '';\n"
  nix << "}\n"
  File.write(File.join(checkout_out_dir, "default.nix"), nix)
end

# -- bundle-path.nix (always regenerated) ---------------------------------
nix = header
nix << "{ pkgs ? import <nixpkgs> {}, ruby ? pkgs.ruby }:\n\nlet\n"
nix << "  gems = import ./default.nix { inherit pkgs ruby; };\n"
nix << "  rubyApiVersion = ruby.version.major + \".\" + ruby.version.minor + \".0\";\n"

unless platform_gems.empty?
  nix << "  hp = pkgs.stdenv.hostPlatform;\n"
  platform_gems.each do |g|
    nix << "  gemPlatform_#{g[:name].gsub("-", "_")} =\n"
    nix << "    #{g[:nix_platform_expr]};\n"
  end
end

# Import git checkout derivations
git_checkouts.each do |checkout_dir, _|
  nix << "  gitCheckout_#{checkout_dir.gsub("-", "_")} = pkgs.callPackage ./_git_#{checkout_dir} {};\n"
end

nix << "in pkgs.stdenv.mkDerivation {\n"
nix << "  pname = \"bundle-path\";\n"
nix << "  version = \"0.0.1\";\n"
nix << "  dontUnpack = true;\n  dontBuild = true;\n  dontConfigure = true;\n\n"
nix << "  installPhase = ''\n"
nix << "    prefix=$out/ruby/${rubyApiVersion}\n"
nix << "    mkdir -p $prefix/gems $prefix/specifications $prefix/bundler/gems\n\n"

# Rubygems-sourced: symlink into ruby/<ver>/gems/ + ruby/<ver>/specifications/
nix << "    # Rubygems-sourced gems\n"
rubygems_gems.each do |g|
  if g[:is_platform_gem]
    pvar = "gemPlatform_#{g[:name].gsub("-", "_")}"
    full_expr = "#{g[:name]}-#{g[:version]}-${#{pvar}}"
    nix << "    ln -s ${gems.\"#{g[:nix_attr]}\"}/gems/#{full_expr} $prefix/gems/#{full_expr}\n"
    nix << "    ln -s ${gems.\"#{g[:nix_attr]}\"}/specifications/#{full_expr}.gemspec $prefix/specifications/#{full_expr}.gemspec\n"
  else
    full = "#{g[:name]}-#{g[:version]}"
    nix << "    ln -s ${gems.\"#{g[:nix_attr]}\"}/gems/#{full} $prefix/gems/#{full}\n"
    nix << "    ln -s ${gems.\"#{g[:nix_attr]}\"}/specifications/#{full}.gemspec $prefix/specifications/#{full}.gemspec\n"
  end
end

# Git-sourced: symlink full checkout dirs at ruby/<ver>/bundler/gems/<base>-<shortref>/
nix << "\n    # Git-sourced gem checkouts (full repo source)\n"
git_checkouts.each do |checkout_dir, _|
  nix_var = "gitCheckout_#{checkout_dir.gsub("-", "_")}"
  nix << "    ln -s ${#{nix_var}} $prefix/bundler/gems/#{checkout_dir}\n"
end

# Gem binstubs in ruby/<ver>/bin/
gems_with_exes = gems.select { |g| !g[:executables].empty? }
unless gems_with_exes.empty?
  nix << "\n    # Gem binstubs\n"
  nix << "    mkdir -p $prefix/bin\n"
  gems_with_exes.each do |g|
    g[:executables].each do |exe|
      if g[:git_source]
        checkout_dir = g[:git_source][:checkout_dir]
        nix_var = "gitCheckout_#{checkout_dir.gsub("-", "_")}"
        source_subdir = g[:source_subdir]
        if source_subdir
          nix << "    ln -sf ${#{nix_var}}/#{source_subdir}/#{g[:bindir]}/#{exe} $prefix/bin/#{exe}\n"
        else
          nix << "    ln -sf ${#{nix_var}}/#{g[:bindir]}/#{exe} $prefix/bin/#{exe}\n"
        end
      elsif g[:is_platform_gem]
        pvar = "gemPlatform_#{g[:name].gsub("-", "_")}"
        full_expr = "#{g[:name]}-#{g[:version]}-${#{pvar}}"
        nix << "    ln -sf ${gems.\"#{g[:nix_attr]}\"}/gems/#{full_expr}/#{g[:bindir]}/#{exe} $prefix/bin/#{exe}\n"
      else
        full = "#{g[:name]}-#{g[:version]}"
        nix << "    ln -sf ${gems.\"#{g[:nix_attr]}\"}/gems/#{full}/#{g[:bindir]}/#{exe} $prefix/bin/#{exe}\n"
      end
    end
  end
end

nix << "  '';\n}\n"
File.write(File.join(output_dir, "bundle-path.nix"), nix)

# -- gemset.json (always regenerated) -------------------------------------

File.write(File.join(output_dir, "gemset.json"), JSON.pretty_generate(
  gems.map { |g|
    h = { name: g[:name], version: g[:version],
          full_name: g[:full_name], nix_attr: g[:nix_attr], deps: g[:deps],
          needs_compilation: g[:needs_compilation], native_deps: g[:native_deps],
          require_paths: g[:require_paths] }
    h[:source_subdir] = g[:source_subdir] if g[:source_subdir]
    h[:is_platform_gem] = true if g[:is_platform_gem]
    h[:git_source] = g[:git_source] if g[:git_source]
    h
  }
))

# -- <name>.deps.nix (always regenerated) ----------------------------------
# A flat list of all gem derivations, importable as a dependency list.

project_name = File.basename(File.dirname(File.expand_path(lockfile_path)))
nix = header
nix << "# All #{gems.size} gems from #{project_name}/Gemfile.lock\n"
nix << "{ pkgs ? import <nixpkgs> {}, ruby ? pkgs.ruby }:\n\n"
nix << "let\n"
nix << "  gems = import ./default.nix { inherit pkgs ruby; };\n"
nix << "in [\n"
gems.sort_by { |g| g[:name] }.each do |g|
  nix << "  gems.\"#{g[:nix_attr]}\"\n"
end
nix << "]\n"
File.write(File.join(output_dir, "#{project_name}.deps.nix"), nix)

$stdout.puts "#{gems.size} generated (#{copied} sources copied). #{gems.size} total."
