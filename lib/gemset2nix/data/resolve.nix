#
# resolve.nix — turn a dependency config into built derivations + devShell
#
# Config format:
#   {
#     deps.gem.app.rails.enable = true;           # app preset
#     deps.gem.rack = { enable = true; version = "3.2.4"; };  # pin a gem
#   }
#
# Usage:
#   resolve = import ./nix/modules/resolve.nix;
#   env = resolve {
#     inherit pkgs ruby;
#     config = { deps.gem.app.fizzy.enable = true; };
#   };
#   env.devShell { buildInputs = with pkgs; [ sqlite ]; }
#
{
  pkgs,
  ruby,
  config,
  # Legacy compat: accept gemset as alias for config
  gemset ? null,
}:

let
  inherit (pkgs) lib stdenv;
  cfg = if gemset != null then gemset else config;

  gem =
    name: args:
    import (../gem + "/${name}") (
      {
        inherit
          lib
          stdenv
          ruby
          pkgs
          ;
      }
      // args
    );

  # All known app presets (generated by bin/import)
  appPresets = import ./apps.nix;

  # Normalize config to a flat list of { name; version; } or { name; git; }
  normalized =
    if builtins.isList cfg then
      # Legacy list format — pass through
      cfg
    else
      let
        # Support both deps.gem.* (new) and gem.* (legacy)
        gemCfg =
          if cfg ? deps && cfg.deps ? gem then cfg.deps.gem
          else if cfg ? gem then cfg.gem
          else {};

        # Expand app presets: deps.gem.app.<name>.enable = true
        appGems =
          if gemCfg ? app then
            let
              enabledApps = lib.filterAttrs (_: v: v.enable or false) gemCfg.app;
              appEntries = lib.concatMap (
                name:
                if appPresets ? ${name} then
                  appPresets.${name}
                else
                  throw "deps.gem.app.${name}: unknown app. Available: ${builtins.concatStringsSep ", " (builtins.attrNames appPresets)}"
              ) (builtins.attrNames enabledApps);
            in
            appEntries
          else
            [ ];

        # Direct gem configs: deps.gem.<name> = { enable = true; version = "..."; }
        directGems =
          let
            filtered = lib.filterAttrs (n: v: n != "app" && builtins.isAttrs v && (v.enable or false)) gemCfg;
          in
          lib.mapAttrsToList (
            name: v:
            if v ? git then
              { inherit name; git = v.git; }
            else
              { inherit name; version = v.version; }
          ) filtered;
      in
      # Direct gems override app gems (by name)
      let
        directByName = builtins.listToAttrs (
          map (e: { name = e.name; value = e; }) directGems
        );
        appFiltered = builtins.filter (e: !(directByName ? ${e.name})) appGems;
      in
      appFiltered ++ directGems;

  resolveEntry =
    entry:
    if entry ? git then
      { name = "${entry.name}-${entry.git.rev}"; value = gem entry.name { inherit (entry) git; }; }
    else
      { inherit (entry) name; value = gem entry.name { inherit (entry) version; }; };

  gems = builtins.listToAttrs (map resolveEntry normalized);

  bundlePath = pkgs.buildEnv {
    name = "gemset2nix-bundle";
    paths = builtins.attrValues gems;
  };
in
gems // {
  inherit bundlePath;

  devShell = {
    name ? "gemset2nix-devshell",
    buildInputs ? [],
    shellHook ? "",
    ...
  }@args:
  pkgs.mkShell (builtins.removeAttrs args ["buildInputs" "shellHook" "name"] // {
    inherit name;
    buildInputs = [ ruby ] ++ buildInputs;
    shellHook = ''
      export BUNDLE_PATH="${bundlePath}"
      export BUNDLE_GEMFILE="''${BUNDLE_GEMFILE:-$PWD/Gemfile}"
    '' + shellHook;
  });
}
